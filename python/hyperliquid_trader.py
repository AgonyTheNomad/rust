#!/usr/bin/env python3
"""
Hyperliquid Trader

This script watches for signal files generated by the Rust signal generator
and executes trades on Hyperliquid using the official Python SDK.
Sensitive information is stored in environment variables rather than config file.
"""

import os
import json
import time
import argparse
import logging
import shutil
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
import asyncio
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

# Import Hyperliquid SDK components
from hyperliquid.info import Info
from hyperliquid.exchange import Exchange
from hyperliquid.utils import constants

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("hyperliquid_trader.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("hyperliquid_trader")

@dataclass
class Signal:
    """Represents a trading signal read from JSON files"""
    id: str
    symbol: str
    timestamp: datetime
    position_type: str  # "Long" or "Short"
    price: float
    reason: str
    strength: float
    take_profit: float
    stop_loss: float
    metadata: dict = None
    processed: bool = False

@dataclass
class Position:
    """Represents an open position"""
    id: str
    symbol: str
    entry_time: datetime
    entry_price: float
    size: float
    stop_loss: float
    take_profit: float
    position_type: str  # "Long" or "Short"
    risk_percent: float
    margin_used: float
    # Track order IDs for management
    entry_order_id: Optional[str] = None
    sl_order_id: Optional[str] = None
    tp_order_id: Optional[str] = None

class SignalProcessor:
    """Handles reading and processing signal files from Rust"""
    
    def __init__(self, trader, signals_dir):
        self.trader = trader
        self.signals_dir = signals_dir
        self.processed_signals = set()
        
    async def scan_existing_signals(self):
        """Scan for existing signal files on startup"""
        try:
            if not os.path.exists(self.signals_dir):
                os.makedirs(self.signals_dir, exist_ok=True)
                logger.info(f"Created signals directory: {self.signals_dir}")
                return
                
            signal_files = [f for f in os.listdir(self.signals_dir) 
                           if f.endswith('.json')]
            
            logger.info(f"Found {len(signal_files)} existing signal files")
            
            # Process files by age (oldest first)
            signal_files.sort()
            
            for filename in signal_files:
                file_path = os.path.join(self.signals_dir, filename)
                await self.process_signal_file(file_path)
                
        except Exception as e:
            logger.error(f"Error scanning existing signals: {e}")
    
    async def process_signal_file(self, file_path):
        """Process a signal file and execute trade if appropriate"""
        try:
            # Skip if already processed this session
            if file_path in self.processed_signals:
                return
                
            self.processed_signals.add(file_path)
            
            with open(file_path, 'r') as f:
                signal_data = json.load(f)
                
            # Skip if already processed
            if signal_data.get('processed', False):
                logger.info(f"Signal {os.path.basename(file_path)} already processed, skipping")
                return
                
            # Convert to Signal object
            signal = Signal(
                id=signal_data.get('id'),
                symbol=signal_data.get('symbol'),
                timestamp=datetime.fromisoformat(signal_data.get('timestamp').replace('Z', '+00:00')),
                position_type=signal_data.get('position_type'),
                price=float(signal_data.get('price')),
                reason=signal_data.get('reason'),
                strength=float(signal_data.get('strength')),
                take_profit=float(signal_data.get('take_profit')),
                stop_loss=float(signal_data.get('stop_loss')),
                metadata=signal_data.get('metadata', {}),
                processed=signal_data.get('processed', False)
            )
            
            # Check signal age
            signal_age = datetime.now(signal.timestamp.tzinfo) - signal.timestamp
            if signal_age > timedelta(minutes=self.trader.max_signal_age_minutes):
                logger.warning(f"Signal {signal.id} is too old ({signal_age.total_seconds()/60:.1f} minutes), skipping")
                await self.mark_signal_processed(file_path)
                return
                
            # Validate and execute if appropriate
            await self.trader.validate_and_execute_signal(signal, file_path)
                
        except Exception as e:
            logger.error(f"Error processing signal file {file_path}: {e}", exc_info=True)
            
    async def mark_signal_processed(self, file_path):
        """Mark a signal file as processed"""
        try:
            with open(file_path, 'r') as f:
                signal_data = json.load(f)
                
            signal_data['processed'] = True
            signal_data['processed_at'] = datetime.now().isoformat()
            
            with open(file_path, 'w') as f:
                json.dump(signal_data, f, indent=2)
                
            logger.info(f"Marked signal {os.path.basename(file_path)} as processed")
            
        except Exception as e:
            logger.error(f"Error marking signal as processed: {e}")

class SystemMonitor:
    """Monitors system health and component status"""
    
    def __init__(self, signals_dir):
        self.signals_dir = signals_dir
        self.last_signal_time = None
        self.signal_count = 0
        
    async def run_heartbeat(self):
        """Run heartbeat check at regular intervals"""
        while True:
            try:
                await self.check_system_status()
                await asyncio.sleep(60)  # Check every minute
            except Exception as e:
                logger.error(f"Error in heartbeat check: {e}")
                await asyncio.sleep(120)  # Longer delay on error
                
    async def check_system_status(self):
        """Check system components status"""
        try:
            # Check signal directory
            signal_files = [f for f in os.listdir(self.signals_dir) 
                           if f.endswith('.json')]
            
            current_count = len(signal_files)
            
            # Check if we're getting new signals
            if current_count > self.signal_count:
                if signal_files:
                    newest_file = max(signal_files, 
                                      key=lambda f: os.path.getmtime(os.path.join(self.signals_dir, f)))
                    newest_time = datetime.fromtimestamp(
                        os.path.getmtime(os.path.join(self.signals_dir, newest_file)))
                    
                    if self.last_signal_time is None:
                        logger.info(f"Initial signal count: {current_count}, newest: {newest_file}")
                    else:
                        logger.info(f"New signals detected: {current_count - self.signal_count}, newest: {newest_file}")
                    
                    self.last_signal_time = newest_time
            
            self.signal_count = current_count
            
            # Check if signal generator is silent for too long
            if self.last_signal_time is not None:
                time_since_last = datetime.now() - self.last_signal_time
                if time_since_last > timedelta(hours=12):
                    logger.warning(f"No new signals in {time_since_last.total_seconds() / 3600:.1f} hours. Check signal generator.")
            
        except Exception as e:
            logger.error(f"Error checking system status: {e}")

class SignalArchiver:
    """Archives old signal files"""
    
    def __init__(self, signals_dir, archive_dir, max_age_days=7):
        self.signals_dir = signals_dir
        self.archive_dir = archive_dir
        self.max_age_days = max_age_days
        
        # Create archive directory if it doesn't exist
        os.makedirs(archive_dir, exist_ok=True)
        
    async def run_archiver(self):
        """Run archiver at regular intervals"""
        while True:
            try:
                await self.archive_old_signals()
                await asyncio.sleep(3600)  # Run every hour
            except Exception as e:
                logger.error(f"Error in signal archiver: {e}")
                await asyncio.sleep(7200)
                
    async def archive_old_signals(self):
        """Archive signal files older than max_age_days"""
        try:
            signal_files = [f for f in os.listdir(self.signals_dir) 
                           if f.endswith('.json')]
            
            now = datetime.now()
            archive_count = 0
            
            for filename in signal_files:
                file_path = os.path.join(self.signals_dir, filename)
                
                # Check file age
                file_time = datetime.fromtimestamp(os.path.getmtime(file_path))
                age_days = (now - file_time).total_seconds() / 86400
                
                if age_days > self.max_age_days:
                    # Check if it's processed
                    try:
                        with open(file_path, 'r') as f:
                            data = json.load(f)
                            if not data.get('processed', False):
                                # Skip unprocessed signals
                                continue
                    except:
                        # If we can't read the file, better to leave it alone
                        continue
                        
                    # Archive the file
                    archive_path = os.path.join(self.archive_dir, filename)
                    shutil.move(file_path, archive_path)
                    archive_count += 1
            
            if archive_count > 0:
                logger.info(f"Archived {archive_count} old signal files")
                
        except Exception as e:
            logger.error(f"Error archiving signals: {e}")

class SignalHandler(FileSystemEventHandler):
    """Watchdog handler for new signal files"""
    
    def __init__(self, signal_processor):
        self.signal_processor = signal_processor
        
    def on_created(self, event):
        if not event.is_directory and event.src_path.endswith('.json'):
            logger.info(f"New signal file detected: {event.src_path}")
            asyncio.create_task(self.signal_processor.process_signal_file(event.src_path))

def send_command(command_dir, command_type, **params):
    """Send a command to the Rust component"""
    try:
        os.makedirs(command_dir, exist_ok=True)
        
        command = {
            "type": command_type,
            **params
        }
        
        timestamp = int(time.time())
        filename = f"{command_type}_{timestamp}.cmd"
        file_path = os.path.join(command_dir, filename)
        
        with open(file_path, 'w') as f:
            json.dump(command, f)
            
        logger.info(f"Sent command {command_type} to signal generator")
        return True
        
    except Exception as e:
        logger.error(f"Error sending command: {e}")
        return False

class HyperliquidTrader:
    """Main trader class for interacting with Hyperliquid"""
    
    def __init__(self, config_path: str, signals_dir: str, dry_run: bool = False):
        self.config_path = config_path
        self.signals_dir = signals_dir
        self.dry_run = dry_run
        self.positions = {}  # Map of symbol -> Position
        
        # Load configuration
        self.load_config()
        
        # Initialize Hyperliquid SDK
        self.init_hyperliquid()
        
    def load_config(self):
        """Load configuration from JSON file and environment variables"""
        try:
            with open(self.config_path, 'r') as f:
                self.config = json.load(f)
            
            # Get sensitive information from environment variables, fall back to config file
            self.account_address = os.environ.get('HYPERLIQUID_ACCOUNT', self.config.get('account_address'))
            self.secret_key = os.environ.get('HYPERLIQUID_KEY', self.config.get('secret_key'))
            
            # Get non-sensitive information from config file
            self.max_positions = self.config.get('max_positions', 5)
            self.use_testnet = self.config.get('use_testnet', True)
            self.risk_per_trade = self.config.get('risk_per_trade', 0.01)
            self.max_signal_age_minutes = self.config.get('max_signal_age_minutes', 5)
            self.symbol_mapping = self.config.get('symbol_mapping', {})
            
            if not self.account_address or not self.secret_key:
                raise ValueError("Missing required fields: HYPERLIQUID_ACCOUNT and HYPERLIQUID_KEY environment variables or corresponding fields in config file")
                
            logger.info(f"Configuration loaded. Using {'testnet' if self.use_testnet else 'mainnet'}")
                
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            raise
            
    def init_hyperliquid(self):
        """Initialize Hyperliquid SDK clients"""
        try:
            # Choose API URL based on testnet setting
            api_url = constants.TESTNET_API_URL if self.use_testnet else constants.MAINNET_API_URL
            
            # Create clients
            self.info = Info(api_url)
            self.exchange = Exchange(api_url, self.secret_key)
            
            logger.info("Hyperliquid SDK initialized")
        except Exception as e:
            logger.error(f"Error initializing Hyperliquid SDK: {e}")
            raise
            
    async def get_account_state(self):
        """Get current account state from Hyperliquid"""
        try:
            user_state = await self.info.user_state(self.account_address)
            return user_state
        except Exception as e:
            logger.error(f"Error getting account state: {e}")
            return None
            
    async def get_current_positions(self):
        """Get currently open positions"""
        try:
            user_state = await self.get_account_state()
            if not user_state:
                return []
                
            positions = []
            for position in user_state.get('assetPositions', []):
                if float(position.get('position', 0)) != 0:
                    positions.append(position)
                    
            return positions
        except Exception as e:
            logger.error(f"Error getting positions: {e}")
            return []
            
    async def get_current_price(self, symbol: str):
        """Get current price for a symbol"""
        try:
            # In Hyperliquid, we need to use the internal asset name
            asset_name = self.map_symbol_to_asset(symbol)
            response = await self.info.l2_book(asset_name)
            
            if not response or 'levels' not in response:
                raise ValueError(f"Invalid response for {symbol} L2 book")
                
            # Calculate mid price from best bid and ask
            if response['levels']['asks'] and response['levels']['bids']:
                best_ask = float(response['levels']['asks'][0][0])
                best_bid = float(response['levels']['bids'][0][0])
                return (best_ask + best_bid) / 2
            else:
                raise ValueError(f"No bid/ask prices available for {symbol}")
                
        except Exception as e:
            logger.error(f"Error getting price for {symbol}: {e}")
            return None
            
    def map_symbol_to_asset(self, symbol: str):
        """Map our internal symbol to Hyperliquid asset name"""
        return self.symbol_mapping.get(symbol, symbol)
            
    async def validate_and_execute_signal(self, signal: Signal, file_path: str):
        """Validate a signal and execute a trade if appropriate"""
        try:
            logger.info(f"Validating signal {signal.id} for {signal.symbol} ({signal.position_type})")
            
            # Check if we can take this trade
            current_positions = await self.get_current_positions()
            if len(current_positions) >= self.max_positions:
                logger.warning(f"Maximum positions ({self.max_positions}) reached, skipping signal {signal.id}")
                await self.signal_processor.mark_signal_processed(file_path)
                return
                
            # Get current price to validate signal
            current_price = await self.get_current_price(signal.symbol)
            if not current_price:
                logger.error(f"Could not get current price for {signal.symbol}, skipping signal {signal.id}")
                return
                
            # Validate price is still valid (within 2% of signal price)
            price_diff_pct = abs(current_price - signal.price) / signal.price
            if price_diff_pct > 0.02:
                logger.warning(f"Price moved too much for {signal.symbol} ({price_diff_pct:.2%}), skipping signal {signal.id}")
                await self.signal_processor.mark_signal_processed(file_path)
                return
                
            # Execute trade
            await self.execute_trade(signal, current_price, file_path)
                
        except Exception as e:
            logger.error(f"Error validating signal: {e}", exc_info=True)
            
    async def execute_trade(self, signal: Signal, current_price: float, file_path: str):
        """Execute a trade based on a signal"""
        try:
            logger.info(f"Executing {signal.position_type} trade for {signal.symbol} at {current_price}")
            
            if self.dry_run:
                logger.info(f"[DRY RUN] Would open {signal.position_type} position for {signal.symbol}")
                await self.signal_processor.mark_signal_processed(file_path)
                return
                
            # Calculate position size using risk management parameters
            account_state = await self.get_account_state()
            if not account_state:
                logger.error("Could not get account state, aborting trade")
                return
                
            # Extract account value
            account_value = float(account_state.get('crossMarginSummary', {}).get('accountValue', 0))
            
            # Calculate risk amount
            risk_amount = account_value * self.risk_per_trade
            
            # Calculate distance to stop loss
            if signal.position_type == "Long":
                stop_distance = signal.price - signal.stop_loss
                is_buy = True
            else:  # Short
                stop_distance = signal.stop_loss - signal.price
                is_buy = False
                
            # Calculate position size
            position_size = risk_amount / stop_distance
            
            # Get asset name for Hyperliquid
            asset_name = self.map_symbol_to_asset(signal.symbol)
            
            # Create order parameters
            order_params = {
                "coin": asset_name,
                "is_buy": is_buy,
                "sz": str(position_size),  # Convert to string for Hyperliquid API
                "reduce_only": False,
                "order_type": {"market": {}},  # Market order
            }
            
            # Create stop loss order
            sl_params = {
                "coin": asset_name, 
                "is_buy": not is_buy,  # Opposite direction
                "sz": str(position_size),
                "reduce_only": True,
                "order_type": {"trigger": {"trigger_px": str(signal.stop_loss), "is_market": True}},
            }
            
            # Create take profit order
            tp_params = {
                "coin": asset_name,
                "is_buy": not is_buy,  # Opposite direction
                "sz": str(position_size),
                "reduce_only": True,
                "order_type": {"trigger": {"trigger_px": str(signal.take_profit), "is_market": True}},
            }
            
            # Execute orders
            entry_response = await self.exchange.place_order(order_params)
            logger.info(f"Entry order response: {entry_response}")
            
            # Extract order ID from response
            entry_order_id = None
            if 'response' in entry_response and 'data' in entry_response['response']:
                statuses = entry_response['response']['data'].get('statuses', [])
                if statuses and 'filled' in statuses[0]:
                    entry_order_id = statuses[0]['filled'].get('oid')
            
            # Place stop loss and take profit orders
            sl_response = await self.exchange.place_order(sl_params)
            logger.info(f"Stop loss order response: {sl_response}")
            sl_order_id = None
            if 'response' in sl_response and 'data' in sl_response['response']:
                statuses = sl_response['response']['data'].get('statuses', [])
                if statuses and 'placed' in statuses[0]:
                    sl_order_id = statuses[0]['placed'].get('oid')
            
            tp_response = await self.exchange.place_order(tp_params)
            logger.info(f"Take profit order response: {tp_response}")
            tp_order_id = None
            if 'response' in tp_response and 'data' in tp_response['response']:
                statuses = tp_response['response']['data'].get('statuses', [])
                if statuses and 'placed' in statuses[0]:
                    tp_order_id = statuses[0]['placed'].get('oid')
            
            # Store position
            position = Position(
                id=f"{signal.symbol}_{datetime.now().timestamp()}",
                symbol=signal.symbol,
                entry_time=datetime.now(),
                entry_price=current_price,
                size=position_size,
                stop_loss=signal.stop_loss,
                take_profit=signal.take_profit,
                position_type=signal.position_type,
                risk_percent=self.risk_per_trade,
                margin_used=0.0,  # Will be calculated from user_state later
                entry_order_id=entry_order_id,
                sl_order_id=sl_order_id,
                tp_order_id=tp_order_id
            )
            
            # Store in our position tracker
            self.positions[signal.symbol] = position
            
            # Mark signal as processed
            await self.signal_processor.mark_signal_processed(file_path)
            
        except Exception as e:
            logger.error(f"Error executing trade: {e}", exc_info=True)
    
    async def monitor_positions(self):
        """Monitor and manage open positions"""
        while True:
            try:
                # Get current positions from exchange
                exchange_positions = await self.get_current_positions()
                
                # Get current prices for position symbols
                prices = {}
                for symbol in self.positions:
                    prices[symbol] = await self.get_current_price(symbol)
                    
                # Check each of our tracked positions
                for symbol, position in list(self.positions.items()):
                    # Check if position is still open on exchange
                    asset_name = self.map_symbol_to_asset(symbol) 
                    is_open = any(p.get('coin') == asset_name and float(p.get('position', 0)) != 0 
                                 for p in exchange_positions)
                    
                    if not is_open:
                        logger.info(f"Position {position.id} for {symbol} has been closed, removing from tracking")
                        del self.positions[symbol]
                        continue
                    
                    # Log current position status if we have price
                    if symbol in prices and prices[symbol]:
                        current_price = prices[symbol]
                        # Calculate unrealized PnL
                        if position.position_type == "Long":
                            pnl_pct = (current_price - position.entry_price) / position.entry_price * 100
                        else:  # Short
                            pnl_pct = (position.entry_price - current_price) / position.entry_price * 100
                            
                        logger.info(f"Position {position.id} for {symbol}: Entry: {position.entry_price}, Current: {current_price}, PnL: {pnl_pct:.2f}%")
                        
                # Sleep to avoid too frequent API calls
                await asyncio.sleep(10)  # Check every 10 seconds
                    
            except Exception as e:
                logger.error(f"Error in position monitor: {e}")
                await asyncio.sleep(30)  # Longer sleep on error

async def main_async():
    parser = argparse.ArgumentParser(description='Hyperliquid Trader')
    parser.add_argument('--config', type=str, default='config.json', help='Path to config file')
    parser.add_argument('--signals', type=str, default='../signals', help='Directory to watch for signals')
    parser.add_argument('--archive', type=str, default='../signals/archive', help='Directory to archive old signals')
    parser.add_argument('--commands', type=str, default='../commands', help='Directory for command files')
    parser.add_argument('--dry-run', action='store_true', help='Run in dry-run mode (no actual trades)')
    
    args = parser.parse_args()
    
    # Create directories if they don't exist
    os.makedirs(args.signals, exist_ok=True)
    os.makedirs(args.archive, exist_ok=True)
    os.makedirs(args.commands, exist_ok=True)
    
    # Initialize trader
    trader = HyperliquidTrader(args.config, args.signals, args.dry_run)
    
    # Create system components
    signal_processor = SignalProcessor(trader, args.signals)
    system_monitor = SystemMonitor(args.signals)
    signal_archiver = SignalArchiver(args.signals, args.archive)
    
    # Attach signal processor to trader for callbacks
    trader.signal_processor = signal_processor
    
    # Start tasks
    position_monitor_task = asyncio.create_task(trader.monitor_positions())
    heartbeat_task = asyncio.create_task(system_monitor.run_heartbeat())
    archiver_task = asyncio.create_task(signal_archiver.run_archiver())
    
    # Process existing signals on startup
    await signal_processor.scan_existing_signals()
    
    # Watch for new signal files
    event_handler = SignalHandler(signal_processor)
    observer = Observer()
    observer.schedule(event_handler, args.signals, recursive=False)
    observer.start()
    
    try:
        logger.info(f"Hyperliquid Trader started. Watching for signals in {args.signals}")
        # Output initial account info
        account_state = await trader.get_account_state()
        if account_state:
            account_value = float(account_state.get('crossMarginSummary', {}).get('accountValue', 0))
            logger.info(f"Initial account value: ${account_value:.2f}")
        
        # Keep the asyncio event loop running
        while True:
            await asyncio.sleep(1)
    except KeyboardInterrupt:
        logger.info("Shutdown requested")
        observer.stop()
        position_monitor_task.cancel()
        heartbeat_task.cancel()
        archiver_task.cancel()
    finally:
        observer.join()
        logger.info("Hyperliquid Trader shutdown complete")

def main():
    """Main entry point"""
    try:
        asyncio.run(main_async())
    except Exception as e:
        logger.critical(f"Fatal error: {e}", exc_info=True)
        sys.exit(1)

if __name__ == "__main__":
    import sys
    main()