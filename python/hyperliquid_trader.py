#!/usr/bin/env python3
"""
Hyperliquid Trader

This script watches for signal files generated by the Rust signal generator
and executes trades on Hyperliquid using the official Python SDK.
Sensitive information is stored in environment variables rather than config file.
"""

import os
import json
import time
import argparse
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
import asyncio
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

# Import Hyperliquid SDK components
from hyperliquid.info import Info
from hyperliquid.exchange import Exchange
from hyperliquid.utils import constants

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("hyperliquid_trader.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("hyperliquid_trader")

@dataclass
class Signal:
    """Represents a trading signal read from JSON files"""
    id: str
    symbol: str
    timestamp: datetime
    position_type: str  # "Long" or "Short"
    price: float
    reason: str
    strength: float
    take_profit: float
    stop_loss: float
    processed: bool = False

@dataclass
class Position:
    """Represents an open position"""
    id: str
    symbol: str
    entry_time: datetime
    entry_price: float
    size: float
    stop_loss: float
    take_profit: float
    position_type: str  # "Long" or "Short"
    risk_percent: float
    margin_used: float
    # Track order IDs for management
    entry_order_id: Optional[str] = None
    sl_order_id: Optional[str] = None
    tp_order_id: Optional[str] = None

class SignalHandler(FileSystemEventHandler):
    """Watchdog handler for new signal files"""
    
    def __init__(self, trader):
        self.trader = trader
        
    def on_created(self, event):
        if not event.is_directory and event.src_path.endswith('.json'):
            logger.info(f"New signal file detected: {event.src_path}")
            asyncio.run(self.trader.process_signal_file(event.src_path))

class HyperliquidTrader:
    """Main trader class for interacting with Hyperliquid"""
    
    def __init__(self, config_path: str, signals_dir: str, dry_run: bool = False):
        self.config_path = config_path
        self.signals_dir = signals_dir
        self.dry_run = dry_run
        self.positions = {}  # Map of symbol -> Position
        
        # Load configuration
        self.load_config()
        
        # Initialize Hyperliquid SDK
        self.init_hyperliquid()
        
    def load_config(self):
        """Load configuration from JSON file and environment variables"""
        try:
            with open(self.config_path, 'r') as f:
                self.config = json.load(f)
            
            # Get sensitive information from environment variables, fall back to config file
            self.account_address = os.environ.get('HYPERLIQUID_ACCOUNT', self.config.get('account_address'))
            self.secret_key = os.environ.get('HYPERLIQUID_KEY', self.config.get('secret_key'))
            
            # Get non-sensitive information from config file
            self.max_positions = self.config.get('max_positions', 5)
            self.use_testnet = self.config.get('use_testnet', True)
            self.risk_per_trade = self.config.get('risk_per_trade', 0.01)
            self.max_signal_age_minutes = self.config.get('max_signal_age_minutes', 5)
            self.symbol_mapping = self.config.get('symbol_mapping', {})
            
            if not self.account_address or not self.secret_key:
                raise ValueError("Missing required fields: HYPERLIQUID_ACCOUNT and HYPERLIQUID_KEY environment variables or corresponding fields in config file")
                
            logger.info(f"Configuration loaded. Using {'testnet' if self.use_testnet else 'mainnet'}")
                
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            raise
            
    def init_hyperliquid(self):
        """Initialize Hyperliquid SDK clients"""
        try:
            # Choose API URL based on testnet setting
            api_url = constants.TESTNET_API_URL if self.use_testnet else constants.MAINNET_API_URL
            
            # Create clients
            self.info = Info(api_url)
            self.exchange = Exchange(api_url, self.secret_key)
            
            logger.info("Hyperliquid SDK initialized")
        except Exception as e:
            logger.error(f"Error initializing Hyperliquid SDK: {e}")
            raise
            
    async def get_account_state(self):
        """Get current account state from Hyperliquid"""
        try:
            user_state = await self.info.user_state(self.account_address)
            return user_state
        except Exception as e:
            logger.error(f"Error getting account state: {e}")
            return None
            
    async def get_current_positions(self):
        """Get currently open positions"""
        try:
            user_state = await self.get_account_state()
            if not user_state:
                return []
                
            positions = []
            for position in user_state.get('assetPositions', []):
                if float(position.get('position', 0)) != 0:
                    positions.append(position)
                    
            return positions
        except Exception as e:
            logger.error(f"Error getting positions: {e}")
            return []
            
    async def get_current_price(self, symbol: str):
        """Get current price for a symbol"""
        try:
            # In Hyperliquid, we need to use the internal asset name
            asset_name = self.map_symbol_to_asset(symbol)
            response = await self.info.l2_book(asset_name)
            
            if not response or 'levels' not in response:
                raise ValueError(f"Invalid response for {symbol} L2 book")
                
            # Calculate mid price from best bid and ask
            if response['levels']['asks'] and response['levels']['bids']:
                best_ask = float(response['levels']['asks'][0][0])
                best_bid = float(response['levels']['bids'][0][0])
                return (best_ask + best_bid) / 2
            else:
                raise ValueError(f"No bid/ask prices available for {symbol}")
                
        except Exception as e:
            logger.error(f"Error getting price for {symbol}: {e}")
            return None
            
    def map_symbol_to_asset(self, symbol: str):
        """Map our internal symbol to Hyperliquid asset name"""
        return self.symbol_mapping.get(symbol, symbol)
            
    async def process_signal_file(self, file_path: str):
        """Process a signal file and execute trade if appropriate"""
        try:
            with open(file_path, 'r') as f:
                signal_data = json.load(f)
                
            # Convert to Signal object
            signal = Signal(
                id=signal_data.get('id'),
                symbol=signal_data.get('symbol'),
                timestamp=datetime.fromisoformat(signal_data.get('timestamp').replace('Z', '+00:00')),
                position_type=signal_data.get('position_type'),
                price=float(signal_data.get('price')),
                reason=signal_data.get('reason'),
                strength=float(signal_data.get('strength')),
                take_profit=float(signal_data.get('take_profit')),
                stop_loss=float(signal_data.get('stop_loss')),
                processed=signal_data.get('processed', False)
            )
            
            if signal.processed:
                logger.info(f"Signal {signal.id} already processed, skipping")
                return
                
            # Check if signal is recent
            signal_age = datetime.now(signal.timestamp.tzinfo) - signal.timestamp
            if signal_age > timedelta(minutes=self.max_signal_age_minutes):
                logger.warning(f"Signal {signal.id} is too old ({signal_age.total_seconds()/60:.1f} minutes), skipping")
                self.mark_signal_processed(file_path)
                return
                
            # Check if we can take this trade
            current_positions = await self.get_current_positions()
            if len(current_positions) >= self.max_positions:
                logger.warning(f"Maximum positions ({self.max_positions}) reached, skipping signal {signal.id}")
                self.mark_signal_processed(file_path)
                return
                
            # Get current price to validate signal
            current_price = await self.get_current_price(signal.symbol)
            if not current_price:
                logger.error(f"Could not get current price for {signal.symbol}, skipping signal {signal.id}")
                return
                
            # Validate price is still valid (within 2% of signal price)
            price_diff_pct = abs(current_price - signal.price) / signal.price
            if price_diff_pct > 0.02:
                logger.warning(f"Price moved too much for {signal.symbol} ({price_diff_pct:.2%}), skipping signal {signal.id}")
                self.mark_signal_processed(file_path)
                return
                
            # Execute trade
            await self.execute_trade(signal, current_price, file_path)
                
        except Exception as e:
            logger.error(f"Error processing signal file {file_path}: {e}")
            
    async def execute_trade(self, signal: Signal, current_price: float, file_path: str):
        """Execute a trade based on a signal"""
        try:
            logger.info(f"Executing {signal.position_type} trade for {signal.symbol} at {current_price}")
            
            if self.dry_run:
                logger.info(f"[DRY RUN] Would open {signal.position_type} position for {signal.symbol}")
                self.mark_signal_processed(file_path)
                return
                
            # Calculate position size using risk management parameters
            account_state = await self.get_account_state()
            if not account_state:
                logger.error("Could not get account state, aborting trade")
                return
                
            # Extract account value
            account_value = float(account_state.get('crossMarginSummary', {}).get('accountValue', 0))
            
            # Calculate risk amount
            risk_amount = account_value * self.risk_per_trade
            
            # Calculate distance to stop loss
            if signal.position_type == "Long":
                stop_distance = signal.price - signal.stop_loss
                is_buy = True
            else:  # Short
                stop_distance = signal.stop_loss - signal.price
                is_buy = False
                
            # Calculate position size
            position_size = risk_amount / stop_distance
            
            # Get asset name for Hyperliquid
            asset_name = self.map_symbol_to_asset(signal.symbol)
            
            # Create order parameters
            order_params = {
                "coin": asset_name,
                "is_buy": is_buy,
                "sz": str(position_size),  # Convert to string for Hyperliquid API
                "reduce_only": False,
                "order_type": {"market": {}},  # Market order
            }
            
            # Create stop loss order
            sl_params = {
                "coin": asset_name, 
                "is_buy": not is_buy,  # Opposite direction
                "sz": str(position_size),
                "reduce_only": True,
                "order_type": {"trigger": {"trigger_px": str(signal.stop_loss), "is_market": True}},
            }
            
            # Create take profit order
            tp_params = {
                "coin": asset_name,
                "is_buy": not is_buy,  # Opposite direction
                "sz": str(position_size),
                "reduce_only": True,
                "order_type": {"trigger": {"trigger_px": str(signal.take_profit), "is_market": True}},
            }
            
            # Execute orders
            entry_response = await self.exchange.place_order(order_params)
            logger.info(f"Entry order response: {entry_response}")
            
            # Extract order ID from response
            entry_order_id = None
            if 'response' in entry_response and 'data' in entry_response['response']:
                statuses = entry_response['response']['data'].get('statuses', [])
                if statuses and 'filled' in statuses[0]:
                    entry_order_id = statuses[0]['filled'].get('oid')
            
            # Place stop loss and take profit orders
            sl_response = await self.exchange.place_order(sl_params)
            logger.info(f"Stop loss order response: {sl_response}")
            sl_order_id = None
            if 'response' in sl_response and 'data' in sl_response['response']:
                statuses = sl_response['response']['data'].get('statuses', [])
                if statuses and 'placed' in statuses[0]:
                    sl_order_id = statuses[0]['placed'].get('oid')
            
            tp_response = await self.exchange.place_order(tp_params)
            logger.info(f"Take profit order response: {tp_response}")
            tp_order_id = None
            if 'response' in tp_response and 'data' in tp_response['response']:
                statuses = tp_response['response']['data'].get('statuses', [])
                if statuses and 'placed' in statuses[0]:
                    tp_order_id = statuses[0]['placed'].get('oid')
            
            # Store position
            position = Position(
                id=f"{signal.symbol}_{datetime.now().timestamp()}",
                symbol=signal.symbol,
                entry_time=datetime.now(),
                entry_price=current_price,
                size=position_size,
                stop_loss=signal.stop_loss,
                take_profit=signal.take_profit,
                position_type=signal.position_type,
                risk_percent=self.risk_per_trade,
                margin_used=0.0,  # Will be calculated from user_state later
                entry_order_id=entry_order_id,
                sl_order_id=sl_order_id,
                tp_order_id=tp_order_id
            )
            
            # Store in our position tracker
            self.positions[signal.symbol] = position
            
            # Mark signal as processed
            self.mark_signal_processed(file_path)
            
        except Exception as e:
            logger.error(f"Error executing trade: {e}")
            
    def mark_signal_processed(self, file_path: str):
        """Mark a signal file as processed"""
        try:
            with open(file_path, 'r') as f:
                signal_data = json.load(f)
                
            signal_data['processed'] = True
            
            with open(file_path, 'w') as f:
                json.dump(signal_data, f, indent=2)
                
            logger.info(f"Marked signal file {file_path} as processed")
        except Exception as e:
            logger.error(f"Error marking signal as processed: {e}")
            
    async def monitor_positions(self):
        """Monitor and manage open positions"""
        while True:
            try:
                # Get current positions from exchange
                exchange_positions = await self.get_current_positions()
                
                # Get current prices for position symbols
                prices = {}
                for symbol in self.positions:
                    prices[symbol] = await self.get_current_price(symbol)
                    
                # Check each of our tracked positions
                for symbol, position in list(self.positions.items()):
                    # Check if position is still open on exchange
                    asset_name = self.map_symbol_to_asset(symbol) 
                    is_open = any(p.get('coin') == asset_name and float(p.get('position', 0)) != 0 
                                 for p in exchange_positions)
                    
                    if not is_open:
                        logger.info(f"Position {position.id} for {symbol} has been closed, removing from tracking")
                        del self.positions[symbol]
                        continue
                        
                # Sleep to avoid too frequent API calls
                await asyncio.sleep(10)  # Check every 10 seconds
                    
            except Exception as e:
                logger.error(f"Error in position monitor: {e}")
                await asyncio.sleep(30)  # Longer sleep on error

async def main_async():
    parser = argparse.ArgumentParser(description='Hyperliquid Trader')
    parser.add_argument('--config', type=str, default='config.json', help='Path to config file')
    parser.add_argument('--signals', type=str, default='../signals', help='Directory to watch for signals')
    parser.add_argument('--dry-run', action='store_true', help='Run in dry-run mode (no actual trades)')
    
    args = parser.parse_args()
    
    trader = HyperliquidTrader(args.config, args.signals, args.dry_run)
    
    # Start the position monitor
    position_monitor_task = asyncio.create_task(trader.monitor_positions())
    
    # Watch for new signal files
    event_handler = SignalHandler(trader)
    observer = Observer()
    observer.schedule(event_handler, args.signals, recursive=False)
    observer.start()
    
    try:
        logger.info(f"Watching for signals in {args.signals}")
        # Keep the asyncio event loop running
        while True:
            await asyncio.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
        position_monitor_task.cancel()
    finally:
        observer.join()

def main():
    asyncio.run(main_async())

if __name__ == "__main__":
    main()